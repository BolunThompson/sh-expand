declare -- BASH="/bin/bash"
declare -r BASHOPTS="cmdhist:complete_fullquote:extquote:force_fignore:hostcomplete:interactive_comments:progcomp:promptvars:sourcepath"
declare -ir BASHPID
declare -A BASH_ALIASES=()
declare -a BASH_ARGC=([0]="1" [1]="1")
declare -a BASH_ARGV=([0]="/tmp/pash_iACTpau/tmp7elaobri" [1]="1-1000")
declare -A BASH_CMDS=()
declare -- BASH_COMMAND
declare -- BASH_EXECUTION_STRING="source /tmp/pash_iACTpau/tmp7elaobri"
declare -a BASH_LINENO=([0]="86" [1]="3716" [2]="0")
declare -a BASH_SOURCE=([0]="/pash/pash/compiler/pash_declare_vars.sh" [1]="/pash/pash/compiler/pash_runtime.sh" [2]="/tmp/pash_iACTpau/tmp7elaobri")
declare -- BASH_SUBSHELL
declare -ar BASH_VERSINFO=([0]="4" [1]="4" [2]="20" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
declare -- BASH_VERSION="4.4.20(1)-release"
declare -- COMP_WORDBREAKS
declare -x DAEMON_SOCKET="/tmp/pash_iACTpau//daemon_socket"
declare -x DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/1006/bus"
declare -a DIRSTACK=()
declare -ir EUID="1006"
declare -x EXP_EXEC_LIBRARY="/pash/posix/tet3.8/vsc/Src/ImplSpec"
declare -x EXP_LIBRARY="/pash/posix/tet3.8/vsc/Lib"
declare -a FUNCNAME
declare -a GROUPS=()
declare -i HISTCMD
declare -x HOME="/home/mgree"
declare -- HOSTNAME="antikythera"
declare -- HOSTTYPE="x86_64"
declare -- IFS=" 	
"
declare -x IGNORE_ERROUT="8"
declare -x IGNORE_OUTPUT="4"
declare -x IGNORE_STATUS="2"
declare -x LANG="POSIX"
declare -x LC_ALL="POSIX"
declare -x LD_LIBRARY_PATH=":/usr/local/lib/"
declare -x LESSCLOSE="/usr/bin/lesspipe %s %s"
declare -x LESSOPEN="| /usr/bin/lesspipe %s"
declare -x LIBVIRT_DEFAULT_URI="qemu:///system"
declare -i LINENO
declare -x LOGNAME="mgree"
declare -x LS_COLORS="rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:"
declare -- MACHTYPE="x86_64-pc-linux-gnu"
declare -x MACROLIB="/pash/posix/tet3.8/vsc/Src/GA/CtgenMacros"
declare -x MAIL="/var/mail/mgree"
declare -x NEGATIVE_TEST="1"
declare -- NEG_CHK="1"
declare -x NULL="NULL"
declare -x OLDPWD="/pash/pash"
declare -- OPTERR="1"
declare -i OPTIND="1"
declare -- OSTYPE="linux-gnu"
declare -x PASH_DEBUG_LEVEL="0"
declare -x PASH_FROM_SH="pa.sh"
declare -x PASH_REDIR="&2"
declare -x PASH_TMP_PREFIX="/tmp/pash_iACTpau/"
declare -x PASH_TOP="/pash/pash"
declare -x PATH="/home/mgree/.local/bin:/pash/posix/tet3.8/vsc/Bin:/pash/posix/tet3.8/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:."
declare -a PIPESTATUS=([0]="0")
declare -- POS_CHK="0"
declare -ir PPID="4949"
declare -- PS4="+ "
declare -x PWD="/pash/posix/tet3.8/vsc/tet_tmp_dir/04912aa/tset/POSIX.shell/shell"
declare -x PYTHONPATH="/pash/pash/python_pkgs/"
declare -i RANDOM
declare -x RUNTIME_DIR="/pash/pash/compiler"
declare -x RUNTIME_IN_FIFO="/tmp/pash_iACTpau//runtime_in_fifo"
declare -x RUNTIME_LIBRARY_DIR="/pash/pash/compiler/../runtime/"
declare -x RUNTIME_OUT_FIFO="/tmp/pash_iACTpau//runtime_out_fifo"
declare -- SECONDS
declare -x SHELL="/bin/bash"
declare -r SHELLOPTS="braceexpand:hashall:interactive-comments"
declare -x SHLVL="4"
declare -x SSH_CLIENT="68.192.246.166 50980 22"
declare -x SSH_CONNECTION="68.192.246.166 50980 128.30.64.121 22"
declare -x SSH_TTY="/dev/pts/0"
declare -x STY="17308.posix"
declare -x TCL_LIBRARY="/pash/posix/tet3.8/vsc/Src/Interact/tcl/library"
declare -x TERM="screen"
declare -x TERMCAP="SC|screen|VT 100/ANSI X3.64 virtual terminal:\\
	:DO=\\E[%dB:LE=\\E[%dD:RI=\\E[%dC:UP=\\E[%dA:bs:bt=\\E[Z:\\
	:cd=\\E[J:ce=\\E[K:cl=\\E[H\\E[J:cm=\\E[%i%d;%dH:ct=\\E[3g:\\
	:do=^J:nd=\\E[C:pt:rc=\\E8:rs=\\Ec:sc=\\E7:st=\\EH:up=\\EM:\\
	:le=^H:bl=^G:cr=^M:it#8:ho=\\E[H:nw=\\EE:ta=^I:is=\\E)0:\\
	:li#24:co#80:am:xn:xv:LP:sr=\\EM:al=\\E[L:AL=\\E[%dL:\\
	:cs=\\E[%i%d;%dr:dl=\\E[M:DL=\\E[%dM:dc=\\E[P:DC=\\E[%dP:\\
	:im=\\E[4h:ei=\\E[4l:mi:IC=\\E[%d@:ks=\\E[?1h\\E=:\\
	:ke=\\E[?1l\\E>:vi=\\E[?25l:ve=\\E[34h\\E[?25h:vs=\\E[34l:\\
	:ti=\\E[?1049h:te=\\E[?1049l:Km=\\E[M:k0=\\E[10~:k1=\\EOP:\\
	:k2=\\EOQ:k3=\\EOR:k4=\\EOS:k5=\\E[15~:k6=\\E[17~:k7=\\E[18~:\\
	:k8=\\E[19~:k9=\\E[20~:k;=\\E[21~:F1=\\E[23~:F2=\\E[24~:\\
	:kh=\\E[1~:@1=\\E[1~:kH=\\E[4~:@7=\\E[4~:kN=\\E[6~:kP=\\E[5~:\\
	:kI=\\E[2~:kD=\\E[3~:ku=\\EOA:kd=\\EOB:kr=\\EOC:kl=\\EOD:"
declare -x TERMIN_EXP="/pash/posix/tet3.8/vsc/Lib/termin.exp"
declare -x TET_ACTIVITY="0"
declare -x TET_CODE="/var/tmp/tccAAA4912"
declare -x TET_CONFIG="/var/tmp/tccAAB4912"
declare -x TET_EXECUTE=""
declare -x TET_FAIL="FAIL"
declare -x TET_FATAL="FATAL"
declare -x TET_INSPECT="INSPECT"
declare -x TET_NORESULT="NORESULT"
declare -x TET_NOTINUSE="NOTINUSE"
declare -x TET_NOT_IMPLEMENTED="NOT_IMPLEMENTED"
declare -x TET_PASS="PASS"
declare -x TET_ROOT="/pash/posix/tet3.8"
declare -x TET_RUN=""
declare -x TET_SUITE_ROOT="/pash/posix/tet3.8"
declare -x TET_TIARGS=""
declare -x TET_UNAPPROVED_ASSERTION="UNAPPROVED_ASSERTION"
declare -x TET_UNINITIATED="UNINITIATED"
declare -x TET_UNRESOLVED="UNRESOLVED"
declare -x TET_UNSUPPORTED="UNSUPPORTED"
declare -x TET_UNTESTED="UNTESTED"
declare -x TS_BIN="/pash/posix/tet3.8/vsc/Bin"
declare -x TS_GAINC="/pash/posix/tet3.8/vsc/Inc/GA"
declare -x TS_INC="/pash/posix/tet3.8/vsc/Inc"
declare -x TS_LIB="/pash/posix/tet3.8/vsc/Lib"
declare -x TS_LIBTK="/pash/posix/tet3.8/vsc/Shlib"
declare -x TS_ROOT="/pash/posix/tet3.8/vsc"
declare -x TS_SHLIB="/pash/posix/tet3.8/vsc/Shlib"
declare -ir UID="1006"
declare -x USER="mgree"
declare -- VSC_COMMAND_UNDER_TEST="sh_08"
declare -x VSC_ERROR="2"
declare -x VSC_FAILURE="1"
declare -- VSC_JRNL_LINES="100"
declare -- VSC_NAP="10"
declare -x VSC_PASS
declare -x VSC_ROOT="/pash/posix/tet3.8/vsc"
declare -- VSC_SUCCESS="0"
declare -x VSC_TESTER_HOME_DIR
declare -- VSC_VARS_H="True"
declare -x WINDOW="0"
declare -x XDG_DATA_DIRS="/usr/local/share:/usr/share:/var/lib/snapd/desktop"
declare -x XDG_RUNTIME_DIR="/run/user/1006"
declare -x XDG_SESSION_ID="29"
declare -- _="Writing vars to: /tmp/pash_iACTpau//pash_rOg0PnkmD9"
declare -- _JrnlLen_="350"
declare -- daemon_response=""
declare -x distro="ubuntu"
declare -- from_set="huBc"
declare -- ic453="tp453"
declare -- ic454="tp454"
declare -- ic455="tp455"
declare -- ic456="tp456"
declare -- ic457="tp457"
declare -- ic458="tp458"
declare -- ic459="tp459"
declare -- ic460="tp460"
declare -- ic461="tp461"
declare -- ic462="tp462"
declare -- ic463="tp463"
declare -- ic464="tp464"
declare -- ic465="tp465"
declare -- ic466="tp466"
declare -- ic467="tp467"
declare -- ic468="tp468"
declare -- ic469="tp469"
declare -- ic470="tp470"
declare -- ic471="tp471"
declare -- ic472="tp472"
declare -- ic473="tp473"
declare -- ic474="tp474"
declare -- ic475="tp475"
declare -- ic476="tp476"
declare -- ic477="tp477"
declare -- ic478="tp478"
declare -- ic479="tp479"
declare -- ic480="tp480"
declare -- ic481="tp481"
declare -- ic482="tp482"
declare -- ic483="tp483"
declare -- ic484="tp484"
declare -- ic485="tp485"
declare -- ic486="tp486"
declare -- ic487="tp487"
declare -- ic488="tp488"
declare -- ic489="tp489"
declare -- ic490="tp490"
declare -- ic491="tp491"
declare -- ic492="tp492"
declare -- ic493="tp493"
declare -- ic494="tp494"
declare -- ic495="tp495"
declare -- ic496="tp496"
declare -- ic497="tp497"
declare -- ic498="tp498"
declare -- ic499="tp499"
declare -- ic500="tp500"
declare -- ic501="tp501"
declare -- ic502="tp502"
declare -- ic503="tp503"
declare -- ic504="tp504"
declare -- ic505="tp505"
declare -- iclist="ic453 ic454 ic455 ic456 ic457 ic458 ic459 ic460 ic461 ic462 ic463 ic464 ic465 ic466 ic467 ic468 ic469 ic470 ic471 ic472 ic473 ic474 ic475 ic476 ic477 ic478 ic479 ic480 ic481 ic482 ic483 ic484 ic485 ic486 ic487 ic488 ic489 ic490 ic491 ic492 ic493 ic494 ic495 ic496 ic497 ic498 ic499 ic500 ic501 ic502 ic503 ic504 ic505"
declare -- internal_exec_status="0"
declare -- msg="Exit:8"
declare -x pash_assert_compiler_success_flag="0"
declare -x pash_avoid_pash_runtime_completion_flag="0"
declare -x pash_checking_debug_level="0"
declare -x pash_checking_log_file="0"
declare -x pash_checking_speculation="0"
declare -- pash_compiled_script_file="/tmp/pash_iACTpau//pash_guU8C1w9In"
declare -x pash_current_set_state="huBc"
declare -x pash_daemon="1"
declare -x pash_daemon_communicates_through_unix_pipes_flag="0"
declare -- pash_default_set_state="huB"
declare -- pash_disable_parallel_pipelines="1"
declare -x pash_dry_run_compiler_flag="0"
declare -- pash_exec_time_start="1637619273671495184"
declare -x pash_execute_flag="1"
declare -x pash_input_args="1-1000"
declare -- pash_input_ir_file="/tmp/pash_iACTpau/tmpfrbm646y"
declare -x pash_output_time_flag="1"
declare -x pash_parallel_pipelines="1"
declare -x pash_previous_exit_status="0"
declare -x pash_previous_set_status="hBc"
declare -- pash_runtime_final_status="0"
declare -- pash_runtime_return_code="1"
declare -- pash_runtime_shell_variables_file="/tmp/pash_iACTpau//pash_rOg0PnkmD9"
declare -- pash_script_to_execute="/tmp/pash_iACTpau/tmp8xps52bm"
declare -- pash_sequential_script_file="/tmp/pash_iACTpau/tmp8xps52bm"
declare -- pash_set_to_add=""
declare -- pash_set_to_remove="u"
declare -x pash_shell_name="sh_08.ex"
declare -x pash_speculation_flag="0"
declare -- process_id="8"
declare -a response_args=([0]="ERROR:" [1]="8" [2]="failed" [3]="to" [4]="compile")
declare -- script_source="/tmp/pash_iACTpau/tmp8xps52bm"
declare -- tet_cleanup="sh_08_cleanup"
declare -- tet_startup="sh_08_startup"
declare -- to_set="hBc"
declare -- traps_set=""
declare -- vars_file="/tmp/pash_iACTpau//pash_rOg0PnkmD9"
CheckPosixVersion () 
{ 
    cpv_min=${1:?};
    cpv_max=${2:?};
    if PosixVersionOK; then
        : ok;
    else
        return 1;
    fi;
    if { 
        test $cpv_min -eq -1 || test $posix_version -ge $cpv_min
    } && { 
        test $cpv_max -eq -1 || test $posix_version -le $cpv_max
    }; then
        return 0;
    else
        SetResult $TET_NOTINUSE "No test when VSC_POSIX_VERSION = $posix_version";
        return 1;
    fi
}
CheckResults () 
{ 
    $CAL_TRACE;
    if [ `expr $6 / $NEGATIVE_TEST % 2` -eq 1 ]; then
        if [ `expr $6 / $IGNORE_STATUS % 2` -eq 1 ] || [ $1 -ne 0 ]; then
            if [ `expr $6 / $IGNORE_ERROUT % 2` -eq 1 ] || [ -s $4 ]; then
                if [ `expr $6 / $IGNORE_OUTPUT % 2` -eq 1 ] || [ -f $3 ] && [ ! -s $3 ]; then
                    return 0;
                else
                    JrnlMsg "Results file size is non-zero and expected zero.";
                    return 3;
                fi;
            else
                JrnlMsg "Error file size is zero and expected non-zero.";
                return 2;
            fi;
        else
            JrnlMsg "Return status is zero and expected non-zero.";
            return 1;
        fi;
    else
        if [ `expr $6 / $IGNORE_OUTPUT % 2` -eq 1 ] || EqualFiles $3 $4; then
            if [ `expr $6 / $IGNORE_STATUS % 2` -eq 1 ] || [ $1 -eq $2 ]; then
                if [ `expr $6 / $IGNORE_ERROUT % 2` -eq 1 ] || [ -f $5 ] && [ ! -s $5 ]; then
                    return 0;
                else
                    JrnlMsg "Error file size is non-zero and expected zero.";
                    return 3;
                fi;
            else
                JrnlMsg "Return status does not match expected return status.";
                LogFailure $2 $1;
                return 2;
            fi;
        else
            JrnlMsg "Results file does not match expected results file.";
            return 1;
        fi;
    fi
}
CheckTestVersions () 
{ 
    ctv_posix_min=${1:?};
    ctv_posix_max=${2:?};
    ctv_xopen_min=${3:?};
    ctv_xopen_max=${4:?};
    if PosixVersionOK && XopenVersionOK; then
        : ok;
    else
        return 1;
    fi;
    if test $xopen_version -eq 0; then
        if { 
            test $ctv_posix_min -eq -1 || test $posix_version -ge $ctv_posix_min
        } && { 
            test $ctv_posix_max -eq -1 || test $posix_version -le $ctv_posix_max
        }; then
            return 0;
        fi;
    else
        if { 
            test $ctv_xopen_min -eq -1 || test $xopen_version -ge $ctv_xopen_min
        } && { 
            test $ctv_xopen_max -eq -1 || test $xopen_version -le $ctv_xopen_max
        }; then
            return 0;
        fi;
    fi;
    SetResult $TET_NOTINUSE "No test when VSC_POSIX_VERSION = $posix_version and VSC_XOPEN_VERSION = $xopen_version";
    return 1
}
CheckXopenVersion () 
{ 
    cpv_min=${1:?};
    cpv_max=${2:?};
    if XopenVersionOK; then
        : ok;
    else
        return 1;
    fi;
    if { 
        test $cpv_min -eq -1 || test $xopen_version -ge $cpv_min
    } && { 
        test $cpv_max -eq -1 || test $xopen_version -le $cpv_max
    }; then
        return 0;
    else
        SetResult $TET_NOTINUSE "No test when VSC_XOPEN_VERSION = $xopen_version";
        return 1;
    fi
}
CloseTP () 
{ 
    $CAL_TRACE;
    __inspectmsg=;
    exit
}
CreateFileName () 
{ 
    $CAL_TRACE;
    if [ $# -eq 0 ]; then
        _FileName="";
    fi;
    if [ $# -eq 4 ]; then
        _FileName=$1_$2_$3.$4;
    else
        _FileName=$1_$2_$3;
    fi;
    if [ -z "$SHORT_FILENAMES" ]; then
        echo $_FileName;
    else
        _CompressFileName_ $_FileName;
    fi
}
CreateTextFile () 
{ 
    $CAL_TRACE;
    echo "$3" > $1;
    chmod $2 $1
}
DeleteAllTPs () 
{ 
    : "${1:?}";
    for dat_ic in $iclist;
    do
        for dat_tp in `eval echo \\$$dat_ic`;
        do
            tet_delete $dat_tp "$*";
        done;
    done
}
DeleteTPRange () 
{ 
    dtr_tpmin=${1:?};
    dtr_tpmax=${2:?};
    shift 2;
    : "${1:?}";
    dtr_tpnum=$((dtr_tpmin - 1));
    while test $((dtr_tpnum += 1)) -le $dtr_tpmax; do
        tet_delete tp$dtr_tpnum "$*";
    done
}
EqualFiles () 
{ 
    $CAL_TRACE;
    if [ ! -r $1 ]; then
        LogWarning "EqualFiles: Unable to open file" $1 "for comparison";
        if [ ! -r $2 ]; then
            LogWarning "EqualFiles: Unable to open file" $2 "for comparison";
        fi;
        return 1;
    else
        if [ ! -r $2 ]; then
            LogWarning "EqualFiles: Unable to open file" $2 "for comparison";
            return 1;
        else
            cmp -s $1 $2;
            return $?;
        fi;
    fi
}
ExecCmdPriv () 
{ 
    $CAL_TRACE;
    ExecuteCommand "setpriv $5 $6 $1" $2 $3 $4
}
ExecuteCommand () 
{ 
    $CAL_TRACE;
    _cmdLine=$1;
    _stdin=$2;
    _stdout=$3;
    _stderr=$4;
    if [ "$2" = "NULL" ]; then
        _stdin="/dev/null";
    fi;
    if [ "$3" = "NULL" ]; then
        _stdout="/dev/null";
    fi;
    if [ "$4" = "NULL" ]; then
        _stderr="/dev/null";
    fi;
    eval $_cmdLine < $_stdin > $_stdout 2> $_stderr
}
FindCommand () 
{ 
    $CAL_TRACE;
    IFS=:;
    for i in $PATH;
    do
        if [ -x $i/$1 ] && [ ! -d $i/$1 ]; then
            echo $i/$1;
            return 0;
        fi;
    done;
    echo $1;
    return 255
}
GetConfig () 
{ 
    if [ $# -eq 0 ]; then
        echo "Usage: GetConfig <config-value> [<pathname>]" 1>&2;
        return $VSC_ERROR;
    fi;
    case $1 in 
        ARG_MAX | CHILD_MAX | CLK_TCK | NGROUPS_MAX | OPEN_MAX | _POSIX_LINK_MAX | _POSIX_MAX_CANON | _POSIX_MAX_INPUT | _POSIX_NAME_MAX | _POSIX_PATH_MAX | _POSIX_PIPE_BUF | _POSIX_ARG_MAX | _POSIX_CHILD_MAX | _POSIX_NGROUPS_MAX | _POSIX_OPEN_MAX | _POSIX_JOB_CONTROL | _POSIX_SAVED_IDS | _POSIX_VERSION)
            Getconf $1 2>&1;
            return $?
        ;;
        LINK_MAX | MAX_CANON | MAX_INPUT | NAME_MAX | PATH_MAX | PIPE_BUF | _POSIX_CHOWN_RESTRICTED | _POSIX_NO_TRUNC | _POSIX_VDISABLE)
            if [ $# -eq 1 ]; then
                echo "GetConfig $1 requires a pathname argument." 1>&2;
                return $VSC_ERROR;
            fi;
            Getconf $1 $2 2>&1;
            return $?
        ;;
        BC_BASE_MAX | BC_DIM_MAX | BC_SCALE_MAX | BC_STRING_MAX | COLL_WEIGHTS_MAX | EXPR_NEST_MAX | LINE_MAX | RE_DUP_MAX | _POSIX2_BC_BASE_MAX | POSIX2_BC_BASE_MAX | _POSIX2_BC_DIM_MAX | POSIX2_BC_DIM_MAX | _POSIX2_BC_SCALE_MAX | POSIX2_BC_SCALE_MAX | _POSIX2_BC_STRING_MAX | POSIX2_BC_STRING_MAX | _POSIX2_COLL_WEIGHTS_MAX | POSIX2_COLL_WEIGHTS_MAX | _POSIX2_EXPR_NEST_MAX | POSIX2_EXPR_NEST_MAX | _POSIX2_LINE_MAX | POSIX2_LINE_MAX | _POSIX2_RE_DUP_MAX | POSIX2_RE_DUP_MAX | _POSIX2_VERSION | POSIX2_VERSION)
            Getconf $1 2>&1;
            return $?
        ;;
        _POSIX2_C_BIND | POSIX2_C_BIND | _POSIX2_C_DEV | POSIX2_C_DEV | _POSIX2_CHAR_TERM | POSIX2_CHAR_TERM | _POSIX2_FORT_DEV | POSIX2_FORT_DEV | _POSIX2_FORT_RUN | POSIX2_FORT_RUN | _POSIX2_LOCALEDEF | POSIX2_LOCALEDEF | _POSIX2_PBS | _POSIX2_PBS_ACCOUNTING | _POSIX2_PBS_LOCATE | _POSIX2_PBS_MESSAGE | _POSIX2_PBS_TRACK | _POSIX2_SW_DEV | POSIX2_SW_DEV | _POSIX2_UPE | POSIX2_UPE)
            getconf_result=$(Getconf $1 2>&1);
            status=$?;
            if [ "$getconf_result" = -1 ]; then
                echo undefined;
            else
                echo $getconf_result;
            fi;
            return $status
        ;;
        NZERO | CHARCLASS_NAME_MAX | TMP_MAX | LONG_BIT | WORD_BIT | _XOPEN_VERSION | NL_ARGMAX | NL_LANGMAX | NL_MSGMAX | NL_SETMAX | NL_TEXTMAX | CHAR_BIT | CHAR_MIN | CLK_TCK | SCHAR_MAX | SCHAR_MIN | SHRT_MAX | CS_PATH | SHRT_MIN | SSIZE_MAX | INT_MAX | INT_MIN | UCHAR_MAX | LONG_MAX | UINT_MAX | LONG_MIN | LONG_MAX | ULONG_MAX | USHRT_MAX | MB_LEN_MAX | NL_NMAX | _XOPEN_XCU_VERSION | _XOPEN_XPG2 | _XOPEN_XPG3 | _XOPEN_XPG4)
            Getconf $1 2>&1;
            return $?
        ;;
        _XOPEN_CRYPT | _XOPEN_ENH_I18N | _XOPEN_SHM)
            getconf_result=$(Getconf $1 2>&1);
            status=$?;
            if [ "$getconf_result" = -1 ]; then
                echo undefined;
            else
                echo $getconf_result;
            fi;
            return $status
        ;;
        *)
            __varname=$1;
            __value=$(eval echo \${$__varname-UnSeTvAr});
            if test "$__value" = "UnSeTvAr"; then
                __errmsg="GetConfig: configuration variable $__varname is not defined";
                if test -z "$tet_thistest"; then
                    JrnlMsg "$__errmsg";
                else
                    SetResult $TET_UNRESOLVED "$__errmsg";
                fi;
                echo "GetConfig-error-return-string";
                return 1;
            fi;
            if [ -n "$__value" ]; then
                echo $__value;
            else
                echo undefined;
            fi;
            return 0
        ;;
    esac
}
GetLocale () 
{ 
    $CAL_TRACE;
    _count=`_ArgCount_ $TET_LOCALES`;
    if [ $_count -eq 0 ]; then
        _locales="";
        return 255;
    else
        _locales=$TET_LOCALES;
        return $_count;
    fi
}
Getconf () 
{ 
    value=$(getconf $* 2>&1);
    status=$?;
    set -- $value;
    if [ $# -ne 1 ]; then
        echo undefined;
    else
        echo $value;
    fi;
    return 0
}
InspectOnError () 
{ 
    $CAL_TRACE;
    if [ "$1" = "-off" ]; then
        __inspectmsg=;
        return;
    fi;
    if [ "$1" = "-interp" ]; then
        __inspectmsg="VSC ignores this error due to $2. Once this issue is resolved, the required behavior will be tested.";
        return;
    fi;
    __inspectmsg=$*
}
IsAllNumeric () 
{ 
    case "${1?}" in 
        "" | *[!0-9]*)
            return 1
        ;;
    esac;
    return 0
}
JrnlDiff () 
{ 
    $CAL_TRACE;
    if [ ! -r "$1" ]; then
        LogError "JrnlDiff: unable to open or read file \"$1\".";
        return 1;
    else
        if [ ! -r "$2" ]; then
            LogError "JrnlDiff: unable to open or read file \"$2\".";
            return 1;
        fi;
    fi;
    diff -c $1 $2 > _JrnlDiffFile 2>&1;
    if [ $? -gt 1 ]; then
        LogError "JrnlDiff: Cannot diff \"$1\" and \"$2\".";
        JrnlFile _JrnlDiffFile;
        return 1;
    fi;
    _lc=`wc -l < _JrnlDiffFile`;
    _lc=`echo $_lc`;
    if [ "$_lc" -gt "$VSC_JRNL_LINES" ]; then
        JrnlMsg "First $VSC_JRNL_LINES lines of diff of \"$1\" and \"$2\":";
        _JrnlFile _JrnlDiffFile $VSC_JRNL_LINES;
    else
        JrnlMsg "diff of \"$1\" and \"$2\":";
        _JrnlFile _JrnlDiffFile 0;
    fi;
    rm _JrnlDiffFile;
    return 0
}
JrnlFile () 
{ 
    $CAL_TRACE;
    if [ ! -r "$1" ]; then
        LogError "JrnlFile: unable to open or read file \"$1\".";
        return 1;
    fi;
    _jfile_=$1;
    tet_infoline "Contents of $_jfile_:";
    _JrnlFile $_jfile_ $VSC_JRNL_LINES;
    return 0
}
JrnlMsg () 
{ 
    $CAL_TRACE;
    tet_infoline "$*"
}
LogError () 
{ 
    $CAL_TRACE;
    JrnlMsg "*ERROR -" $*
}
LogFailure () 
{ 
    $CAL_TRACE;
    JrnlMsg "Expected return: ($1), Actual return: ($2)"
}
LogWarning () 
{ 
    $CAL_TRACE;
    JrnlMsg "*WARNING -" $*
}
OpenTP () 
{ 
    $CAL_TRACE;
    OPENTP=1;
    JrnlMsg "Assertion #$2 ($3): $4";
    _testCmd=`FindCommand $1`;
    echo $_testCmd;
    if [ -z "$_testCmd" ]; then
        LogError "$1 not found in search path:";
        JrnlMsg "$PATH";
        tet_result $TET_FAIL;
        tet_setblock;
        return 1;
    fi;
    return 0
}
PosixVersionOK () 
{ 
    if IsAllNumeric "$posix_version"; then
        return 0;
    else
        SetResult $TET_UNRESOLVED "internal error: bad posix_version = $posix_version";
        return 1;
    fi
}
SetPosixVersion () 
{ 
    tet_setblock;
    posix_version="`GetConfig VSC_POSIX_VERSION`";
    spv_rc=$?;
    tet_setblock;
    if test $spv_rc -ne 0 || test -z "$posix_version" || test "$posix_version" = undefined; then
        JrnlMsg "configuration variable VSC_POSIX_VERSION is not set";
        return 1;
    else
        if IsAllNumeric "$posix_version"; then
            return 0;
        else
            JrnlMsg "configuration variable VSC_POSIX_VERSION is not numeric";
            return 1;
        fi;
    fi
}
SetResult () 
{ 
    $CAL_TRACE;
    __result=$1;
    if [ -n "$__inspectmsg" ] && [ "$__result" != $TET_PASS ]; then
        tet_result $TET_PASS;
        JrnlMsg "WARNING: $__inspectmsg";
        if [ ! -z "$2" ]; then
            JrnlMsg "$2";
        fi;
    else
        tet_result $__result;
        if [ ! -z "$2" ]; then
            JrnlMsg "$2";
        fi;
    fi
}
SetTestVersions () 
{ 
    stv_rc=0;
    SetPosixVersion || stv_rc=1;
    SetXopenVersion || stv_rc=1;
    return $stv_rc
}
SetXopenVersion () 
{ 
    tet_setblock;
    xopen_version="`GetConfig VSC_XOPEN_VERSION`";
    sxv_rc=$?;
    tet_setblock;
    if test $sxv_rc -ne 0 || test -z "$xopen_version" || test "$xopen_version" = undefined; then
        JrnlMsg "configuration variable VSC_XOPEN_VERSION is not set";
        return 1;
    else
        if IsAllNumeric "$xopen_version"; then
            return 0;
        else
            JrnlMsg "configuration variable VSC_XOPEN_VERSION is not numeric";
            return 1;
        fi;
    fi
}
SetupLocale () 
{ 
    $CAL_TRACE;
    _count=`_ArgCount_ $_locales`;
    LANG=${_locales%% *};
    if [ `_ArgCount_ $_locales` -gt 1 ]; then
        _locales=${_locales#* };
    else
        _locales="";
    fi;
    return
}
TraceMsg () 
{ 
    if [ $# -le 1 ]; then
        JrnlMsg "*WARNING - TraceMsg: called without parameters";
        return 1;
    fi;
    case $TMSG_LEVEL in 
        TMSG_TERSE | TMSG_SHORT | TMSG_VERBOSE | TMSG_DEBUG)

        ;;
        *)
            JrnlMsg "WARNING - TraceMsg: Invalid TMSG_LEVEL \"$TMSG_LEVEL\"";
            return 2
        ;;
    esac;
    case $1 in 
        TMSG_TERSE)
            shift;
            JrnlMsg $@
        ;;
        TMSG_SHORT)
            case $TMSG_LEVEL in 
                TMSG_SHORT | TMSG_VERBOSE | TMSG_DEBUG)
                    shift;
                    JrnlMsg $@
                ;;
                *)

                ;;
            esac
        ;;
        TMSG_VERBOSE)
            case $TMSG_LEVEL in 
                TMSG_VERBOSE | TMSG_DEBUG)
                    shift;
                    JrnlMsg $@
                ;;
                *)

                ;;
            esac
        ;;
        TMSG_DEBUG)
            case $TMSG_LEVEL in 
                TMSG_DEBUG)
                    shift;
                    JrnlMsg $@
                ;;
                *)

                ;;
            esac
        ;;
        *)
            echo "Error: Invalid level \"$1\" given." 1>&2;
            return 2
        ;;
    esac;
    return 0
}
XopenVersionOK () 
{ 
    if IsAllNumeric "$xopen_version"; then
        return 0;
    else
        SetResult $TET_UNRESOLVED "internal error: bad xopen_version = $xopen_version";
        return 1;
    fi
}
_ArgCount_ () 
{ 
    $CAL_TRACE;
    echo $#
}
_CompressFileName_ () 
{ 
    $CAL_TRACE;
    echo $1
}
_JrnlFile () 
{ 
    $CAL_TRACE;
    SaveIFS="$IFS";
    _jfile_=$1;
    _lim=$2;
    if [ "X$_lim" = "X" ] || [ $_lim -eq 0 ] || [ -z "$_lim" ]; then
        _lim=9999999;
    fi;
    IFS="";
    _jrnl_ct=0;
    while read -r _jrnl_line_; do
        tet_infoline "$_jrnl_line_";
        _jrnl_ct=$(( $_jrnl_ct + 1));
        if [ $_jrnl_ct -ge $_lim ]; then
            tet_infoline "...omitting remaining lines.";
            break;
        fi;
    done < $_jfile_;
    IFS="$SaveIFS"
}
clean_up () 
{ 
    if [ "$pash_daemon" -eq 1 ]; then
        msg="Exit:${process_id}";
        daemon_response=$(pash_communicate_daemon_just_send "$msg");
    fi
}
final_steps () 
{ 
    if [ "$PASH_DEBUG_LEVEL" -ne 0 ] && [ "$pash_avoid_pash_runtime_completion_flag" -ne 1 ]; then
        pash_output_var_file="$($RUNTIME_DIR/pash_ptempfile_name.sh $distro)";
        pash_output_set_file="$($RUNTIME_DIR/pash_ptempfile_name.sh $distro)";
        source "$RUNTIME_DIR/pash_runtime_shell_to_pash.sh" ${pash_output_var_file} ${pash_output_set_file};
        source "$RUNTIME_DIR/pash_runtime_complete_execution.sh";
    fi
}
pash_communicate_daemon () 
{ 
    local message=$1;
    pash_redir_output echo "Sending msg to daemon: $message";
    daemon_response=$(echo "$message" | nc -U "$DAEMON_SOCKET");
    pash_redir_output echo "Got response from daemon: $daemon_response";
    echo "$daemon_response"
}
declare -fx pash_communicate_daemon
pash_communicate_daemon_just_send () 
{ 
    pash_communicate_daemon $1
}
declare -fx pash_communicate_daemon_just_send
pash_redir_all_output () 
{ 
    :
}
declare -fx pash_redir_all_output
pash_redir_all_output_always_execute () 
{ 
    $@ > /dev/null 2>&1
}
declare -fx pash_redir_all_output_always_execute
pash_redir_output () 
{ 
    :
}
declare -fx pash_redir_output
pash_wait_until_daemon_listening () 
{ 
    i=0;
    maximum_retries=100;
    while ! nc -z -U "$DAEMON_SOCKET" > /dev/null 2>&1; do
        sleep 0.01;
        i=$((i+1));
        if [ $i -eq $maximum_retries ]; then
            echo "Error: Maximum retries: $maximum_retries exceeded when waiting for daemon to bind to socket!" 1>&2;
            echo "Exiting..." 1>&2;
            exit 1;
        fi;
    done
}
declare -fx pash_wait_until_daemon_listening
run_parallel () 
{ 
    trap clean_up SIGTERM SIGINT EXIT;
    source "$RUNTIME_DIR/pash_wrap_vars.sh" ${pash_script_to_execute};
    internal_exec_status=$?;
    final_steps;
    clean_up;
    ( exit $internal_exec_status )
}
sh_08_cleanup () 
{ 
    rm -f sh8*.eso sh8*.in sh8*.out sh8*.sh sh8*.ex
}
sh_08_startup () 
{ 
    VSC_TESTER_HOME_DIR=`GetPwNam -dir $VSC_TESTER`;
    PATH=${PATH}:.;
    if SetTestVersions; then
        : ok;
    else
        for tpnum in 453 460;
        do
            tet_delete tp${tpnum} "a required configuration variable is not set correctly";
        done;
    fi
}
tp453 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 453 A "The standard output of each command in a pipeline except the last is connected to the standard input of the next command"`;
    tet_setblock;
    pwd > sh8_453.eso;
    if [ $? -ne 0 ]; then
        SetResult $TET_UNRESOLVED "Command failed: 'pwd 1> sh8_453.eso'";
        return;
    fi;
    pwd | cat > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    cmp -s $CT_STDOUT sh8_453.eso;
    if [ ! $? -eq 0 ]; then
        SetResult $TET_FAIL "Standard output isn't the same as file 'sh8_453.eso'";
        JrnlDiff $CT_STDOUT sh8_453.eso;
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if test $posix_version -ge 200809 || test $xopen_version -ge 700; then
        ( echo teststring;
        GetFD0Type 0<&1 > sh8_453_out1.t ) | ( cat;
        GetFD0Type > sh8_453_in2.t;
        GetFD0Type 0<&1 > sh8_453_out2.t ) | ( cat;
        GetFD0Type > sh8_453_in3.t ) > sh8_453.out;
        [ "$(cat sh8_453_out1.t)" = p ];
        if [ $? -ne 0 ]; then
            SetResult $TET_FAIL "Command failed: '[ \"\$(cat sh8_453_out1.t)\" = p ]'";
        else
            SetResult $TET_PASS;
        fi;
        [ "$(cat sh8_453_in2.t)" = p ];
        if [ $? -ne 0 ]; then
            SetResult $TET_FAIL "Command failed: '[ \"\$(cat sh8_453_in2.t)\" = p ]'";
        else
            SetResult $TET_PASS;
        fi;
        [ "$(cat sh8_453_out2.t)" = p ];
        if [ $? -ne 0 ]; then
            SetResult $TET_FAIL "Command failed: '[ \"\$(cat sh8_453_out2.t)\" = p ]'";
        else
            SetResult $TET_PASS;
        fi;
        [ "$(cat sh8_453_in3.t)" = p ];
        if [ $? -ne 0 ]; then
            SetResult $TET_FAIL "Command failed: '[ \"\$(cat sh8_453_in3.t)\" = p ]'";
        else
            SetResult $TET_PASS;
        fi;
    fi;
    rm -f sh8_453_*.t;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp454 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 454 A "standard input, standard output or both of a command in a pipeline are assigned before any redirection"`;
    tet_setblock;
    echo hello > shell_in_454;
    if [ $? -ne 0 ]; then
        SetResult $TET_UNRESOLVED "Command failed: 'echo hello > shell_in_454'";
        return;
    fi;
    echo goodbye > /dev/null | cat > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
        if [ -s $CT_STDERR ]; then
            JrnlFile $CT_STDERR;
        fi;
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    echo goodbye | cat < shell_in_454 > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
        if [ -s $CT_STDERR ]; then
            JrnlFile $CT_STDERR;
        fi;
    else
        SetResult $TET_PASS;
    fi;
    cmp -s $CT_STDOUT shell_in_454;
    if [ ! $? -eq 0 ]; then
        SetResult $TET_FAIL "Standard output isn't the same as file 'shell_in_454'";
        JrnlDiff $CT_STDOUT shell_in_454;
    else
        SetResult $TET_PASS;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp455 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 455 A "shell waits for the last command in a pipeline to complete"`;
    tet_setblock;
    Interval=10;
    Minwait=$(( $Interval - 1 ));
    Start=`GetNow`;
    echo hello | cat | cat | cat | sleep 10;
    End=`GetNow`;
    Elapsed=$(( $End - $Start ));
    [ $Elapsed -ge $Minwait ];
    if [ $? -ne 0 ]; then
        SetResult $TET_FAIL "Command failed: '[ $Elapsed -ge $Minwait ]'";
    else
        SetResult $TET_PASS;
    fi;
    CloseTP
}
tp456 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 456 A "exit status of a pipeline is the exit status of the last command"`;
    tet_setblock;
    printf "exit 17\n" > shell_456.sh && chmod +x shell_456.sh;
    if [ $? -ne 0 ]; then
        SetResult $TET_UNRESOLVED "Command failed: 'printf \"exit 17\n\" > shell_456.sh && chmod +x shell_456.sh'";
        return;
    fi;
    pwd | shell_456.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 17 ]; then
        SetResult $TET_FAIL "Expected exit code = 17; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp457 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 457 A "exit status of a pipeline preceded by ! is the logical NOT if the exit status of the last command"`;
    tet_setblock;
    printf "exit 17\n" > shell_457.sh && chmod +x shell_457.sh;
    if [ $? -ne 0 ]; then
        SetResult $TET_UNRESOLVED "Command failed: 'printf \"exit 17\n\" > shell_457.sh && chmod +x shell_457.sh'";
        return;
    fi;
    ! ./shell_457.sh | ./shell_457.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    printf "exit 0\n" > shell_457a.sh && chmod +x shell_457a.sh;
    if [ $? -ne 0 ]; then
        SetResult $TET_UNRESOLVED "Command failed: 'printf \"exit 0\n\" > shell_457a.sh && chmod +x shell_457a.sh'";
        return;
    fi;
    ! ./shell_457a.sh | ./shell_457a.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 1 ]; then
        SetResult $TET_FAIL "Expected exit code = 1; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp458 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 458 A "The AND and OR operators have equal precedence and are evaluated by the shell beginning to end"`;
    tet_setblock;
    rm -f D458.*;
    true || mkdir D458.1 && false || mkdir D458.2 > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    [ ! -d D458.1 ] && [ -d D458.2 ];
    if [ $? -ne 0 ]; then
        SetResult $TET_FAIL "Command failed: '[ ! -d D458.1 ] && [ -d D458.2 ]'";
    else
        SetResult $TET_PASS;
    fi;
    true && mkdir D458.3 || false || mkdir D458.4 && true && mkdir D458.5 > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    [ -d D458.3 ] && [ ! -d D458.4 ] && [ -d D458.5 ];
    if [ $? -ne 0 ]; then
        SetResult $TET_FAIL "Command failed: '[ -d D458.3 ] && [ ! -d D458.4 ] && [ -d D458.5 ]'";
    else
        SetResult $TET_PASS;
    fi;
    rm -rf D458.?;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp459 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 459 A "Terminating & puts process in the background."`;
    tet_setblock;
    cat  > sh8_459.sh <<EOF
export sh8_459_var=sh8_459_string
sleep $VSC_NAP
EOF

    chmod +x sh8_459.sh;
    sh8_459.sh &  > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    env | grep sh8_459_var > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 1 ]; then
        SetResult $TET_FAIL "Expected exit code = 1; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp460 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 460 A "When ... then the standard input for an asynchronous list is redirected to a file which has the same properties as /dev/null"`;
    tet_setblock;
    cat  > sh8_460.sh <<'EOF'
case $- in
*m*) set +m ;;
esac
exec < sh8_460.in
cat &
wait
EOF

    chmod +x sh8_460.sh;
    echo This line should not be read > sh8_460.in;
    if [ $? -ne 0 ]; then
        SetResult $TET_UNRESOLVED "Command failed: 'echo This line should not be read > sh8_460.in'";
        return;
    fi;
    sh8_460.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if test $posix_version -ge 200809 || test $xopen_version -ge 700; then
        if [ `GetConfig VSC_EXPECT_SUPPORT` = TRUE ]; then
            expectFile=sh8_460.ex;
            cat > $expectFile  <<-'EOF'
spawn -noecho sh
expect "$ "
send "set +m\r"
expect "$ "
send "( exec < sh8_460.in; cat > sh8_460.out & wait )\r"
expect "$ "
send "exit\r"
expect eof
EOF

            expect -f $expectFile > $CT_STDOUT 2> $CT_STDERR;
            CT_EXIT_VALUE=$?;
            if [ $CT_EXIT_VALUE -ne 0 ]; then
                SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
            else
                SetResult $TET_PASS;
            fi;
            if [ ! -s $CT_STDERR ]; then
                SetResult $TET_PASS;
            else
                SetResult $TET_FAIL "Standard error isn't empty";
                JrnlFile $CT_STDERR;
            fi;
            test ! -s sh8_460.out;
            if [ $? -ne 0 ]; then
                SetResult $TET_FAIL "Command failed: 'test ! -s sh8_460.out'";
            else
                SetResult $TET_PASS;
            fi;
        fi;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp461 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 461 A "special parameter ! returns process ID of background process"`;
    tet_setblock;
    cat  > sh8_461_1.sh <<EOF
sh8_461_2.sh&
#wait for background process to end
sleep \$1
background_pid=\`cat sh8_461_pid.out\`
if [ "\$!" -eq "\$background_pid" ]
then
	exit 0
else 
	exit 1
fi
EOF

    cat  > sh8_461_2.sh <<EOF
echo \$$  > sh8_461_pid.out
EOF

    cat  > sh8_461_3.sh <<EOF
basename `pwd` | sh8_461_2.sh&
#wait for background process to end
sleep \$1
background_pid=\`cat sh8_461_pid.out\`
if [ "\$!" -eq "\$background_pid" ]
then
	exit 0
else 
	exit 1
fi
EOF

    chmod +x sh8_461_1.sh sh8_461_2.sh sh8_461_3.sh;
    sh8_461_1.sh $VSC_NAP > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    rm sh8_461_pid.out;
    sh8_461_3.sh $VSC_NAP > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp462 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 462 A "process id availability from background processes"`;
    tet_setblock;
    cat  > sh8_462_1.sh <<EOF
sh8_462_2.sh&
first_background_pid=\$!
pwd | (basename `pwd`;cat) | sh8_462_3.sh&
sleep \$1
background_pid_1=\`cat sh8_462_pid_1.out\`
background_pid_2=\`cat sh8_462_pid_2.out\`
if [ \$first_background_pid -ne \$! ]
then
	if [ \$first_background_pid -eq \$background_pid_1 ]
	then
		if [ \$! -eq \$background_pid_2 ]
		then
			exit 0
		fi
	fi
fi
exit 1

EOF

    cat  > sh8_462_2.sh <<EOF
echo \$$  > sh8_462_pid_1.out
EOF

    cat  > sh8_462_3.sh <<EOF
echo \$$  > sh8_462_pid_2.out
cat > /dev/null #Consume data from pipe so writers don't get SIGPIPE
EOF

    chmod +x sh8_462_1.sh sh8_462_2.sh sh8_462_3.sh;
    sh8_462_1.sh $VSC_NAP > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp463 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 463 A "exit status from an asynchronouus list is zero"`;
    tet_setblock;
    pwd > /dev/null &  > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
        if [ -s $CT_STDERR ]; then
            JrnlFile $CT_STDERR;
        fi;
    else
        SetResult $TET_PASS;
    fi;
    false &  > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
        if [ -s $CT_STDERR ]; then
            JrnlFile $CT_STDERR;
        fi;
    else
        SetResult $TET_PASS;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp464 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 464 A "Commands in a sequential list (.i.e commands separated by a ;) are executed sequentially"`;
    tet_setblock;
    cat  > sh8_464_1.sh <<EOF
echo 1
EOF

    cat  > sh8_464_2.sh <<EOF
echo 2
EOF

    cat  > sh8_464_3.sh <<EOF
echo 3
EOF

    cat  > sh8_464.eso <<EOF
1
2
3
EOF

    chmod +x sh8_464_1.sh sh8_464_2.sh sh8_464_3.sh;
    sh8_464_1.sh > sh8_464.out;
    sh8_464_2.sh >> sh8_464.out;
    sh8_464_3.sh >> sh8_464.out;
    if [ $? -ne 0 ]; then
        SetResult $TET_UNRESOLVED "Command failed: 'sh8_464_1.sh > sh8_464.out ; sh8_464_2.sh >> sh8_464.out; sh8_464_3.sh>> sh8_464.out'";
        return;
    fi;
    diff sh8_464.eso sh8_464.out > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
        if [ -s $CT_STDERR ]; then
            JrnlFile $CT_STDERR;
        fi;
    else
        SetResult $TET_PASS;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp465 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 465 A "The exit status of a sequential list is the exit status of the last command in the list"`;
    tet_setblock;
    cat  > sh8_465_1.sh <<EOF
exit 1
EOF

    cat  > sh8_465_2.sh <<EOF
exit 2
EOF

    cat  > sh8_465_3.sh <<EOF
exit 3
EOF

    chmod +x sh8_465_1.sh sh8_465_2.sh sh8_465_3.sh;
    sh8_465_1.sh;
    sh8_465_2.sh;
    sh8_465_3.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 3 ]; then
        SetResult $TET_FAIL "Expected exit code = 3; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp466 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 466 A "When a command in an AND list is executed and exits with an exit status of zero, then the next command is executed"`;
    tet_setblock;
    cat  > sh8_466_1.sh <<EOF
exit 0
EOF

    cat  > sh8_466_2.sh <<EOF
echo "hello"
exit 99
EOF

    echo "hello" > sh8_466.eso;
    chmod +x sh8_466_1.sh sh8_466_2.sh;
    sh8_466_1.sh && sh8_466_2.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 99 ]; then
        SetResult $TET_FAIL "Expected exit code = 99; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    cmp -s $CT_STDOUT sh8_466.eso;
    if [ ! $? -eq 0 ]; then
        SetResult $TET_FAIL "Standard output isn't the same as file 'sh8_466.eso'";
        JrnlDiff $CT_STDOUT sh8_466.eso;
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp467 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 467 A ""`;
    tet_setblock;
    cat  > sh8_467_1.sh <<EOF
exit 1
EOF

    cat  > sh8_467_2.sh <<EOF
echo "hello"
exit 99
EOF

    echo "hello" > sh8_467.eso;
    chmod +x sh8_467_1.sh sh8_467_2.sh;
    sh8_467_1.sh && sh8_467_2.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 1 ]; then
        SetResult $TET_FAIL "Expected exit code = 1; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp468 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 468 A "The exit status of an AND list is the exit status of the last command that is executed"`;
    tet_setblock;
    cat  > sh8_468_1.sh <<EOF
exit 0
EOF

    cat  > sh8_468_2.sh <<EOF
exit 1
EOF

    cat  > sh8_468_3.sh <<EOF
echo "hello"
exit 99
EOF

    echo "hello" > sh8_468.eso;
    chmod +x sh8_468_1.sh sh8_468_2.sh sh8_468_3.sh;
    sh8_468_1.sh && sh8_468_3.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 99 ]; then
        SetResult $TET_FAIL "Expected exit code = 99; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    cmp -s $CT_STDOUT sh8_468.eso;
    if [ ! $? -eq 0 ]; then
        SetResult $TET_FAIL "Standard output isn't the same as file 'sh8_468.eso'";
        JrnlDiff $CT_STDOUT sh8_468.eso;
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_468_2.sh && sh8_468_3.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 1 ]; then
        SetResult $TET_FAIL "Expected exit code = 1; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp469 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 469 A "When a command in an OR list is executed and exits with a non-zero exit status, then the next command is executed"`;
    tet_setblock;
    cat  > sh8_466_1.sh <<EOF
exit 1
EOF

    cat  > sh8_466_2.sh <<EOF
echo "hello"
exit 99
EOF

    echo "hello" > sh8_466.eso;
    chmod +x sh8_466_1.sh sh8_466_2.sh;
    sh8_466_1.sh || sh8_466_2.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 99 ]; then
        SetResult $TET_FAIL "Expected exit code = 99; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    cmp -s $CT_STDOUT sh8_466.eso;
    if [ ! $? -eq 0 ]; then
        SetResult $TET_FAIL "Standard output isn't the same as file 'sh8_466.eso'";
        JrnlDiff $CT_STDOUT sh8_466.eso;
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp470 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 470 A "When a command in an OR list is executed and exits with a zero exit status, then no futher commands in the list are executed"`;
    tet_setblock;
    cat  > sh8_470_1.sh <<EOF
exit 0
EOF

    cat  > sh8_470_2.sh <<EOF
echo "hello"
exit 99
EOF

    echo "hello" > sh8_470.eso;
    chmod +x sh8_470_1.sh sh8_470_2.sh;
    sh8_470_1.sh || sh8_470_2.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp471 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 471 A "The exit status of an AND list is the exit status of the last command that is executed"`;
    tet_setblock;
    cat  > sh8_471_1.sh <<EOF
exit 1
EOF

    cat  > sh8_471_2.sh <<EOF
exit 0
EOF

    cat  > sh8_471_3.sh <<EOF
echo "hello"
exit 99
EOF

    echo "hello" > sh8_471.eso;
    chmod +x sh8_471_1.sh sh8_471_2.sh sh8_471_3.sh;
    sh8_471_1.sh || sh8_471_3.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 99 ]; then
        SetResult $TET_FAIL "Expected exit code = 99; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    cmp -s $CT_STDOUT sh8_471.eso;
    if [ ! $? -eq 0 ]; then
        SetResult $TET_FAIL "Standard output isn't the same as file 'sh8_471.eso'";
        JrnlDiff $CT_STDOUT sh8_471.eso;
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    rm -f $CT_STDOUT $CT_STDERR;
    sh8_471_2.sh || sh8_471_3.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp472 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 472 A "compound command contains redirections on the same line as the compound command terminator"`;
    tet_setblock;
    cat  > sh8_472.sh <<EOF
for i in sh8_472_1.out sh8_472_2.out sh8_472_3.out
do
echo \$i > \$i
ls \$i
cat \$i
done > sh8_472.out
EOF

    cat  > sh8_472.eso <<EOF
sh8_472_1.out
sh8_472_1.out
sh8_472_2.out
sh8_472_2.out
sh8_472_3.out
sh8_472_3.out
EOF

    chmod +x sh8_472.sh;
    sh8_472.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    diff sh8_472.eso sh8_472.out > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
        if [ -s $CT_STDERR ]; then
            JrnlFile $CT_STDERR;
        fi;
    else
        SetResult $TET_PASS;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp473 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 473 A "compound list of the form (list) is executed in a subshell"`;
    tet_setblock;
    cat  > sh8_473.sh <<EOF
export sh8_473_var=sh8_473_string
sleep $VSC_NAP
EOF

    chmod +x sh8_473.sh;
    sh8_473.sh &  > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    env | grep sh8_473_var > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 1 ]; then
        SetResult $TET_FAIL "Expected exit code = 1; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp474 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 474 A "Variable assignments and built-in commands that affect the environment do not remain in effect after the (list) finishes"`;
    tet_setblock;
    ( var1=string1;
    export var2=string2 );
    if [ $? -ne 0 ]; then
        SetResult $TET_UNRESOLVED "Command failed: '(var1=string1;export var2=string2)'";
        return;
    fi;
    set | grep var1 > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 1 ]; then
        SetResult $TET_FAIL "Expected exit code = 1; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    env | grep var2 > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 1 ]; then
        SetResult $TET_FAIL "Expected exit code = 1; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp475 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 475 A "A compound list in the form { list; } is executed in the curent process environment"`;
    tet_setblock;
    { 
        var1=string1;
        export var2=string2
    };
    set | grep var1 > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output is empty";
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    env | grep var2 > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output is empty";
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp476 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 476 A "he exit status of a grouping command is the exit status of the list"`;
    tet_setblock;
    cat  > sh8_476_1.sh <<EOF
exit 1
EOF

    cat  > sh8_476_2.sh <<EOF
exit 99
EOF

    chmod +x sh8_476_1.sh sh8_476_2.sh;
    { 
        sh8_476_1.sh;
        sh8_476_2.sh
    } > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 99 ]; then
        SetResult $TET_FAIL "Expected exit code = 99; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    ( sh8_476_1.sh;
    sh8_476_2.sh ) > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 99 ]; then
        SetResult $TET_FAIL "Expected exit code = 99; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp477 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 477 A "for loop executes a sequence of commands for each member in a group of item"`;
    tet_setblock;
    cat  > sh8_477.sh <<EOF
for i in sh8_477_1.out sh8_477_2.out sh8_477_3.out 
do
echo \$i > \$i
ls \$i
cat \$i
done
EOF

    cat  > sh8_477.eso <<EOF
sh8_477_1.out
sh8_477_1.out
sh8_477_2.out
sh8_477_2.out
sh8_477_3.out
sh8_477_3.out
EOF

    chmod +x sh8_477.sh;
    sh8_477.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    cmp -s $CT_STDOUT sh8_477.eso;
    if [ ! $? -eq 0 ]; then
        SetResult $TET_FAIL "Standard output isn't the same as file 'sh8_477.eso'";
        JrnlDiff $CT_STDOUT sh8_477.eso;
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp478 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 478 A "commands executed in the for loop are delimited by the words do and done"`;
    tet_setblock;
    cat  > sh8_478.sh <<EOF
for i in sh8_478_1.out sh8_478_2.out sh8_478_3.out 
do
echo \$i > \$i
ls \$i
cat \$i
done
echo "After done statement"
EOF

    cat  > sh8_478.eso <<EOF
sh8_478_1.out
sh8_478_1.out
sh8_478_2.out
sh8_478_2.out
sh8_478_3.out
sh8_478_3.out
After done statement
EOF

    chmod +x sh8_478.sh;
    sh8_478.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    cmp -s $CT_STDOUT sh8_478.eso;
    if [ ! $? -eq 0 ]; then
        SetResult $TET_FAIL "Standard output isn't the same as file 'sh8_478.eso'";
        JrnlDiff $CT_STDOUT sh8_478.eso;
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp479 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 479 A "The list of words following in is expanded to generate a list of words"`;
    tet_setblock;
    cat  > sh8_479.sh <<EOF
for i in sh8_479_1.out sh8_479_2.out sh8_479_3.out 
do
echo \$i 
done
EOF

    cat  > sh8_479.eso <<EOF
sh8_479_1.out
sh8_479_2.out
sh8_479_3.out
EOF

    chmod +x sh8_479.sh;
    sh8_479.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    cmp -s $CT_STDOUT sh8_479.eso;
    if [ ! $? -eq 0 ]; then
        SetResult $TET_FAIL "Standard output isn't the same as file 'sh8_479.eso'";
        JrnlDiff $CT_STDOUT sh8_479.eso;
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp480 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 480 A "When no list is given (.e. in word is ommitted), then the list is generated as $@"`;
    tet_setblock;
    cat  > sh8_480.sh <<EOF
for i 
do
echo \$i 
done
EOF

    cat  > sh8_480.eso <<EOF
sh8_480_1.out
sh8_480_2.out
sh8_480_3.out
EOF

    chmod +x sh8_480.sh;
    sh8_480.sh sh8_480_1.out sh8_480_2.out sh8_480_3.out > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    cmp -s $CT_STDOUT sh8_480.eso;
    if [ ! $? -eq 0 ]; then
        SetResult $TET_FAIL "Standard output isn't the same as file 'sh8_480.eso'";
        JrnlDiff $CT_STDOUT sh8_480.eso;
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp481 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 481 A "exit status of a for command is the exit status of the last command that executes"`;
    tet_setblock;
    cat  > sh8_481.sh <<EOF
for i in sh8_481_1.sh  sh8_481_2.sh sh8_481_3.sh  
do
\$i 
done
EOF

    cat  > sh8_481_1.sh <<EOF
exit 10
EOF

    cat  > sh8_481_2.sh <<EOF
exit 50
EOF

    cat  > sh8_481_3.sh <<EOF
exit 99
EOF

    chmod +x sh8_481.sh sh8_481_1.sh sh8_481_2.sh sh8_481_3.sh;
    sh8_481.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 99 ]; then
        SetResult $TET_FAIL "Expected exit code = 99; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp482 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 482 A "When there are no items in the list, then the exit status is zero"`;
    tet_setblock;
    cat  > sh8_482.sh <<EOF
for i
do
echo \$i 
done
EOF

    chmod +x sh8_482.sh;
    sh8_482.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp483 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 483 A "The reserved word in denotes the beginning of the patterns to be matched"`;
    tet_setblock;
    sh8_case_1.sh A > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 1 ]; then
        SetResult $TET_FAIL "Expected exit code = 1; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_case_1.sh B > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 2 ]; then
        SetResult $TET_FAIL "Expected exit code = 2; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_case_1.sh C > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 3 ]; then
        SetResult $TET_FAIL "Expected exit code = 3; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp484 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 484 A "Multiple patterns with the same compound list are delimited by the | symbol"`;
    tet_setblock;
    sh8_case_2.sh A > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 1 ]; then
        SetResult $TET_FAIL "Expected exit code = 1; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_case_2.sh B > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 1 ]; then
        SetResult $TET_FAIL "Expected exit code = 1; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_case_2.sh C > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 2 ]; then
        SetResult $TET_FAIL "Expected exit code = 2; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_case_2.sh D > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 2 ]; then
        SetResult $TET_FAIL "Expected exit code = 2; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_case_2.sh E > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 3 ]; then
        SetResult $TET_FAIL "Expected exit code = 3; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_case_2.sh F > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 3 ]; then
        SetResult $TET_FAIL "Expected exit code = 3; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_case_2.sh G > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 3 ]; then
        SetResult $TET_FAIL "Expected exit code = 3; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp485 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 485 A "control operator ) terminates a list of patterns corresponding to a given action"`;
    tet_setblock;
    sh8_case_2.sh A > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 1 ]; then
        SetResult $TET_FAIL "Expected exit code = 1; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_case_2.sh B > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 1 ]; then
        SetResult $TET_FAIL "Expected exit code = 1; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_case_2.sh C > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 2 ]; then
        SetResult $TET_FAIL "Expected exit code = 2; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_case_2.sh D > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 2 ]; then
        SetResult $TET_FAIL "Expected exit code = 2; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_case_2.sh E > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 3 ]; then
        SetResult $TET_FAIL "Expected exit code = 3; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_case_2.sh F > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 3 ]; then
        SetResult $TET_FAIL "Expected exit code = 3; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_case_2.sh G > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 3 ]; then
        SetResult $TET_FAIL "Expected exit code = 3; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp486 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 486 A "compound list corresponding to any pattern except the last is terminated with ;;"`;
    tet_setblock;
    sh8_case_1.sh A > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 1 ]; then
        SetResult $TET_FAIL "Expected exit code = 1; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_case_1.sh B > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 2 ]; then
        SetResult $TET_FAIL "Expected exit code = 2; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_case_1.sh C > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 3 ]; then
        SetResult $TET_FAIL "Expected exit code = 3; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp487 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 487 A "case construct is terminated with the reserved word esac"`;
    tet_setblock;
    sh8_case_1.sh A > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 1 ]; then
        SetResult $TET_FAIL "Expected exit code = 1; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_case_1.sh B > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 2 ]; then
        SetResult $TET_FAIL "Expected exit code = 2; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_case_1.sh C > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 3 ]; then
        SetResult $TET_FAIL "Expected exit code = 3; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp488 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 488 A "case construct is terminated with the reserved word esac"`;
    tet_setblock;
    cat  > sh8_488.sh <<EOF
if [ \$1 = "v" ]
then
	var=C
	case \${var} in
		A) exit 1;;
		B) exit 2;;
		C) exit 3
	esac
elif [ \$1 = "t" ]
then
	case ~$VSC_TESTER in
		A) exit 1;;
		$VSC_TESTER_HOME_DIR) exit 2;;
		C) exit 3
	esac

elif [ \$1 = "c" ]
then
	pwd=\`pwd\`
	case \`pwd\` in
		\$pwd) exit 1;;
		B) exit 2;;
		C) exit 3
	esac
elif [ \$1 = "a" ]
then
	case \$((1+1)) in
		A) exit 1;;
		B) exit 2;;
		2) exit 3
	esac
elif [ \$1 = "qq" ]
then
	case "A" in
		A) exit 1;;
		B) exit 2;;
		2) exit 3
	esac
elif [ \$1 = "qa" ]
then
	case 'B' in
		A) exit 1;;
		B) exit 2;;
		2) exit 3
	esac
elif [ \$1 = "qs" ]
then
	case \2 in
		A) exit 1;;
		B) exit 2;;
		2) exit 3
	esac
fi
EOF

    chmod +x sh8_488.sh;
    sh8_488.sh v > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 3 ]; then
        SetResult $TET_FAIL "Expected exit code = 3; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_488.sh t > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 2 ]; then
        SetResult $TET_FAIL "Expected exit code = 2; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_488.sh c > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 1 ]; then
        SetResult $TET_FAIL "Expected exit code = 1; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_488.sh a > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 3 ]; then
        SetResult $TET_FAIL "Expected exit code = 3; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_488.sh qq > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 1 ]; then
        SetResult $TET_FAIL "Expected exit code = 1; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_488.sh qa > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 2 ]; then
        SetResult $TET_FAIL "Expected exit code = 2; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_488.sh qs > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 3 ]; then
        SetResult $TET_FAIL "Expected exit code = 3; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp489 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 489 A "Each pattern in a pattern list is expanded and compared against the expansion of word"`;
    tet_setblock;
    cat  > sh8_489.sh <<EOF
var=string_489
case \$1 in 
	\${var}|A|B) exit 1;;
	\`pwd\`|C|D) exit 2;;
	\$((128*256))|E|F) exit 3;;
	~$VSC_TESTER|G|H) exit 4
esac
EOF

    chmod +x sh8_489.sh;
    sh8_489.sh string_489 > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 1 ]; then
        SetResult $TET_FAIL "Expected exit code = 1; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_489.sh `pwd` > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 2 ]; then
        SetResult $TET_FAIL "Expected exit code = 2; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_489.sh $((128*256)) > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 3 ]; then
        SetResult $TET_FAIL "Expected exit code = 3; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_489.sh $VSC_TESTER_HOME_DIR > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 4 ]; then
        SetResult $TET_FAIL "Expected exit code = 4; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp490 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 490 A "Each pattern in a pattern list is expanded and compared against the expansion of word"`;
    tet_setblock;
    cat  > sh8_490.sh <<EOF
var=string_490
case \$1 in 
	\${var}|A|B) exit 1;;
	\`pwd\`|C|D) exit 2;;
	\$((128*256))|E|F) exit 3;;
	~$VSC_TESTER|G|H) exit 4
esac
EOF

    chmod +x sh8_490.sh;
    sh8_490.sh string_490 > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 1 ]; then
        SetResult $TET_FAIL "Expected exit code = 1; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_490.sh `pwd` > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 2 ]; then
        SetResult $TET_FAIL "Expected exit code = 2; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_490.sh $((128*256)) > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 3 ]; then
        SetResult $TET_FAIL "Expected exit code = 3; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_490.sh $VSC_TESTER_HOME_DIR > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 4 ]; then
        SetResult $TET_FAIL "Expected exit code = 4; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp491 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 491 A "When no patterns in the pattern list matches the expansion of word, then the exit status is zero"`;
    tet_setblock;
    sh8_case_1.sh XYZ > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    cat  > sh8_491.sh <<'EOF'
case "[0-9]" in 
	[0-9]) echo pattern should not have matched; exit 99;;
esac
EOF

    chmod +x sh8_491.sh;
    sh8_491.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp492 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 492 A ""`;
    tet_setblock;
    cat  > sh8_492.sh <<EOF
case A in 
	1)  ls;;
	A)  pwd;;
	string) ls
esac
EOF

    chmod +x sh8_492.sh;
    sh8_492.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    grep -e `pwd` $CT_STDOUT > /dev/null;
    if [ ! $? -eq 0 ]; then
        SetResult $TET_FAIL "\`pwd\` wasn't found in standard output";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp493 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 493 A "if command executes a compound-list and when the exit status of that compound-list is zero, executes a second compound-list associated with the correspoonding then"`;
    tet_setblock;
    cat  > sh8_493.sh <<EOF
if [ 1 -eq 1 ]
then
	exit 99
fi
EOF

    chmod +x sh8_493.sh;
    sh8_493.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 99 ]; then
        SetResult $TET_FAIL "Expected exit code = 99; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp494 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 494 A "if command with non-zero status, and elif command with zero status"`;
    tet_setblock;
    cat  > sh8_494.sh <<EOF
if [ 1 -eq 0 ]
then
	exit 1
elif [ 1 -eq 3 ]
then 
	exit 2
elif [ 1 -eq 1 ]
then
	exit 99
fi
EOF

    chmod +x sh8_494.sh;
    sh8_494.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 99 ]; then
        SetResult $TET_FAIL "Expected exit code = 99; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp495 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 495 A "When none of the compound lists associated with either the if or subsequent elif commands evaluates to zero, then the else compound list is executed"`;
    tet_setblock;
    cat  > sh8_495_1.sh <<EOF
if [ 1 -eq 0 ] 
then
	exit 1
else
	exit 99
fi
EOF

    cat  > sh8_495_2.sh <<EOF
if [ 1 -eq 0 ] 
then
	exit 1
elif [ 1 -eq 2 ]
then
	exit 1
elif [ 1 -eq 3 ]
then
	exit 1
else
	exit 99
fi
EOF

    chmod +x sh8_495_1.sh sh8_495_2.sh;
    sh8_495_1.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 99 ]; then
        SetResult $TET_FAIL "Expected exit code = 99; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_495_2.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 99 ]; then
        SetResult $TET_FAIL "Expected exit code = 99; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp496 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 496 A "The exit status of the if command is the exit status of the then or else compound list that was executed"`;
    tet_setblock;
    cat  > sh8_496_1.sh <<EOF
if [ 1 -eq 1 ]
then
	exit 99
fi
EOF

    cat  > sh8_496_2.sh <<EOF
if [ 1 -eq 0 ]
then
	exit 9
else
	exit 99
fi
EOF

    chmod +x sh8_496_1.sh sh8_496_2.sh;
    sh8_496_1.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 99 ]; then
        SetResult $TET_FAIL "Expected exit code = 99; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    sh8_496_2.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 99 ]; then
        SetResult $TET_FAIL "Expected exit code = 99; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp497 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 497 A "When no then or else compound list is executed, then the exit status of the if command is zero"`;
    tet_setblock;
    cat  > sh8_497.sh <<EOF
if [ 1 -eq 0 ]
then
	exit 99
fi
EOF

    chmod +x sh8_497.sh;
    sh8_497.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp498 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 498 A "while compound-list is executed and exits with a zero exit status"`;
    tet_setblock;
    cat  > sh8_498.sh <<EOF
i=0
while [ \$i -lt 3 ]
do
	i=\`expr \$i + 1\`
	echo \$i
done
EOF

    chmod +x sh8_498.sh;
    cat  > sh8_498.eso <<EOF
1
2
3
EOF

    sh8_498.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    cmp -s $CT_STDOUT sh8_498.eso;
    if [ ! $? -eq 0 ]; then
        SetResult $TET_FAIL "Standard output isn't the same as file 'sh8_498.eso'";
        JrnlDiff $CT_STDOUT sh8_498.eso;
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp499 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 499 A "while compound-list is executed and exits with a non-zero exit status"`;
    tet_setblock;
    cat  > sh8_499.sh <<EOF
i=0
while [ \$i -lt 3 ]
do
	i=\`expr \$i + 1\`
	echo \$i
done
EOF

    chmod +x sh8_499.sh;
    cat  > sh8_499.eso <<EOF
1
2
3
EOF

    sh8_499.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    cmp -s $CT_STDOUT sh8_499.eso;
    if [ ! $? -eq 0 ]; then
        SetResult $TET_FAIL "Standard output isn't the same as file 'sh8_499.eso'";
        JrnlDiff $CT_STDOUT sh8_499.eso;
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp500 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 500 A ""`;
    tet_setblock;
    cat  > sh8_500_1.sh <<EOF
i=0
while [ \$i -lt 3 ]
do
	i=\`expr \$i + 1\`
	sh8_500_2.sh \$i
done
EOF

    cat  > sh8_500_2.sh <<EOF
exit \$1
EOF

    chmod +x sh8_500_1.sh sh8_500_2.sh;
    sh8_500_1.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 3 ]; then
        SetResult $TET_FAIL "Expected exit code = 3; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp501 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 501 A "while compound-list is executed and exits with a non-zero exit status"`;
    tet_setblock;
    cat  > sh8_501.sh <<EOF
i=5
while [ \$i -lt 3 ]
do
	i=\`expr \$i + 1\`
	echo \$i
done
EOF

    chmod +x sh8_501.sh;
    sh8_501.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp502 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 502 A "until compound-list is executed and exits with a non-zero exit status"`;
    tet_setblock;
    cat  > sh8_502.sh <<EOF
i=0
until [ \$i -eq 3 ]
do
	i=\`expr \$i + 1\`
	echo \$i
done
EOF

    chmod +x sh8_502.sh;
    cat  > sh8_502.eso <<EOF
1
2
3
EOF

    sh8_502.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    cmp -s $CT_STDOUT sh8_502.eso;
    if [ ! $? -eq 0 ]; then
        SetResult $TET_FAIL "Standard output isn't the same as file 'sh8_502.eso'";
        JrnlDiff $CT_STDOUT sh8_502.eso;
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp503 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 503 A "When the until compound-list is executed and exits with a zero status, then the command completes"`;
    tet_setblock;
    cat  > sh8_503.sh <<EOF
i=0
until [ \$i -eq 3 ]
do
	i=\`expr \$i + 1\`
	echo \$i
done
EOF

    chmod +x sh8_503.sh;
    cat  > sh8_503.eso <<EOF
1
2
3
EOF

    sh8_503.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    cmp -s $CT_STDOUT sh8_503.eso;
    if [ ! $? -eq 0 ]; then
        SetResult $TET_FAIL "Standard output isn't the same as file 'sh8_503.eso'";
        JrnlDiff $CT_STDOUT sh8_503.eso;
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp504 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 504 A "When a do compound-list is executed from an until command, then the exit status of the until loop is the exit status of the last compound list executed"`;
    tet_setblock;
    cat  > sh8_504_1.sh <<EOF
i=0
until [ \$i -eq 3 ]
do
	i=\`expr \$i + 1\`
	sh8_504_2.sh \$i
done
EOF

    cat  > sh8_504_2.sh <<EOF
exit \$1
EOF

    chmod +x sh8_504_1.sh sh8_504_2.sh;
    sh8_504_1.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 3 ]; then
        SetResult $TET_FAIL "Expected exit code = 3; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}
tp505 () 
{ 
    $TST_TRACE;
    CT_STDOUT=out.stdout;
    CT_STDERR=out.stderr;
    cmd=`OpenTP sh_08 505 A "When no do compound-list is executed from a until command, then the exit status of the until loop is zero"`;
    tet_setblock;
    cat  > sh8_505.sh <<EOF
i=0
until [ \$i -lt 3 ]
do
	i=\`expr \$i + 1\`
	echo \$i
done
EOF

    chmod +x sh8_505.sh;
    sh8_505.sh > $CT_STDOUT 2> $CT_STDERR;
    CT_EXIT_VALUE=$?;
    if [ $CT_EXIT_VALUE -ne 0 ]; then
        SetResult $TET_FAIL "Expected exit code = 0; Received $CT_EXIT_VALUE";
    else
        SetResult $TET_PASS;
    fi;
    if [ ! -s $CT_STDOUT ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard output isn't empty";
        JrnlFile $CT_STDOUT;
    fi;
    if [ ! -s $CT_STDERR ]; then
        SetResult $TET_PASS;
    else
        SetResult $TET_FAIL "Standard error isn't empty";
        JrnlFile $CT_STDERR;
    fi;
    if [ -z "$VSC_DEBUG" ]; then
        rm -f $CT_STDOUT $CT_STDERR;
    fi;
    CloseTP
}

